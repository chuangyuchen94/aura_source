### 0. 总结

### 1. 任务概述
- 推荐系统
  - 音乐数据处理
    - 播放数据：属于`行为数据`
  - 基于商品相似性的推荐
  - 基于SVD矩阵分解的推荐

### 2. 数据读取
- 在数据中，只需要用户、歌曲、播放量
- 数据预处理
  - 对于数值型类型，根据实际情况进行判断，如果int32或float32就能够满足需求，就没必要用int64或float64，在数据预处理时，可以对类型进行转换，这样可以减少内存的占用，提高训练效率

### 3. 对每一个用户，分别统计他的播放总量
- 统计每个用户的总播放量
- 按播放量倒序排序
- 过滤掉播放量太少的数据

### 4. 对于每一首歌，分别统计它的播放总量
- 统计每首歌的播放总量
- 按播放总量倒序排序

### 5. 看看目前的排行情况

### 6. 取其中一部分数，作为实验数据
- 以数据量从大到小来取
- 例如，取前100000条数据，看这些数据的数据量占总数据量达到多少（或者，按照占比的阈值来取数）
- 总共取10W个用户，3W首歌（例子）
- 过滤掉其他用户数据
  - 先按用户过滤
  - 再按歌曲过滤

### 7. 加入音乐详细信息
- 当前的音乐数据只有id值，需要将其转换为详细的信息
- 合并两份数据：音乐播放记录，音乐详细信息
- 对音乐详细信息进行处理
  - 删除没用的信息

### 8. 推荐系统
- 方法1：简单暴力，排行榜单推荐
- 方法2：基于歌曲`相似度`的推荐
  - 选择一小部分歌曲来实验：选择前5000条数据
  - 用户听过哪些歌
    - 基于用户听过的歌，找到与这些歌曲相似的歌
  - 用户听过的歌，又被哪些用户听过
  - 在整个歌曲集当中，遍历每一个歌曲，计算它与用户每一个听过的歌曲的相似度矩阵
    - 求相似系数：
      - 用户听过的这首歌，被什么人听过（人群A）；
      - 其他的一首歌曲，被什么人听过（人群B）；
      - 求人群A和人群B的交集、并集；
      - 相似系数 = 交集 / 并集
      - 相似系数越大，则两首歌越相似
    - 得到用户听过的歌，与歌曲库的每一首歌的相似度
  - 遍历歌曲库中的每一首歌，判断是否要被推荐
    - 对歌曲库中每一首歌的推荐系数的得分值，算平均值
  - 缺点：执行慢
- 方法3：基于SVD矩阵分解
  - 矩阵分解：
    - 特征压缩、特征降维
  - 给歌曲打分
    - 已有：用户表单，歌曲表单
    - 歌曲被当前用户播放的次数 / 用户的歌曲播放总次数
    - 先把userid和songid转换为数值型的user_index和song_index
    - 稀疏矩阵
    - 工具
      - from scipy.sparse.linalg import *
      - from scipy.sparse import svds
      - from scipy.sparse import csc_matrix
    - 