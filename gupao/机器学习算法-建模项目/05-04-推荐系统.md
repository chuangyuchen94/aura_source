### 0. 总结
- SVD用于实现推荐系统的原理：
  - 基于已知数据，来推算缺失数据
    - 用户对于有些物品的评分是已经评分的，对于其他物品，还未评分；
    - SVD的作用，是将用户特征与物品特征，通过U、S、V进行分解，在将U、S、V进行相乘，就能填补其他缺失的数据
- 需要构建“用户-物品”评分矩阵，
  - (用户ID, 物品ID, 评分)
- 再转换成稀疏矩阵，
  - 其列为每种物品评分，行为每个用户对物品的评分

### 1. 任务概述
- 推荐系统
  - 音乐数据处理
    - 播放数据：属于`行为数据`
  - 基于商品相似性的推荐
  - 基于SVD矩阵分解的推荐

### 2. 数据读取
- 在数据中，只需要用户、歌曲、播放量
- 数据预处理
  - 对于数值型类型，根据实际情况进行判断，如果int32或float32就能够满足需求，就没必要用int64或float64，在数据预处理时，可以对类型进行转换，这样可以减少内存的占用，提高训练效率

### 3. 对每一个用户，分别统计他的播放总量
- 统计每个用户的总播放量
- 按播放量倒序排序
- 过滤掉播放量太少的数据

### 4. 对于每一首歌，分别统计它的播放总量
- 统计每首歌的播放总量
- 按播放总量倒序排序

### 5. 看看目前的排行情况

### 6. 取其中一部分数，作为实验数据
- 以数据量从大到小来取
- 例如，取前100000条数据，看这些数据的数据量占总数据量达到多少（或者，按照占比的阈值来取数）
- 总共取10W个用户，3W首歌（例子）
- 过滤掉其他用户数据
  - 先按用户过滤
  - 再按歌曲过滤

### 7. 加入音乐详细信息
- 当前的音乐数据只有id值，需要将其转换为详细的信息
- 合并两份数据：音乐播放记录，音乐详细信息
- 对音乐详细信息进行处理
  - 删除没用的信息

### 8. 推荐系统
- 方法1：简单暴力，排行榜单推荐
- 方法2：基于歌曲`相似度`的推荐
  - 选择一小部分歌曲来实验：选择前5000条数据
  - 用户听过哪些歌
    - 基于用户听过的歌，找到与这些歌曲相似的歌
  - 用户听过的歌，又被哪些用户听过
  - 在整个歌曲集当中，遍历每一个歌曲，计算它与用户每一个听过的歌曲的相似度矩阵
    - `求相似系数`：
      - 用户听过的这首歌，被什么人听过（人群A）；
      - 其他的一首歌曲，被什么人听过（人群B）；
      - 求人群A和人群B的交集、并集；
      - 相似系数 = 交集 / 并集
      - 相似系数越大，则两首歌越相似
    - 得到用户听过的歌，与歌曲库的每一首歌的相似度
  - 遍历歌曲库中的每一首歌，判断是否要被推荐
    - 对歌曲库中每一首歌的推荐系数的得分值，算平均值
  - 缺点：执行慢
- 方法3：基于SVD矩阵分解
  - 矩阵分解：
    - 特征压缩、特征降维
  - `给歌曲打分`
    - 已有：用户表单，歌曲表单
    - 歌曲被当前用户播放的次数 / 用户的歌曲播放总次数
    - 先把userid和songid转换为数值型的user_index和song_index
    - 稀疏矩阵
    - 工具
      - from scipy.sparse.linalg import *
      - from scipy.sparse import svds
      - from scipy.sparse import csc_matrix

### 9. SVD矩阵分解
- SVD：将1个矩阵分解为3个矩阵相乘的方法（$U, Σ, V$），$A = UΣV^T$
  - $U$：左奇异向量矩阵，列向量正交（$U^TU = I$）
  - $V$：右奇异向量矩阵，列向量正交（$V^TV = I$）
  - $Σ$：是对角矩阵，对角线上的元素是奇异值
- 计算步骤
  - 1）计算$A^TA$的特征向量，得到$U$的列
  - 2）计算$AA^T$的特征向量，得到$V$的列
  - 3）求奇异值：
    - $Σ$的对角元素为$A^TA$或$AA^T$的特征值的平方根，按降序排列
  - 4）构造矩阵
- 应用场景
  - 降维与压缩
  - 推荐系统
  - 图像压缩
  - 违逆计算
  - 自然语言处理
- 在实际应用中，常使用
  - 紧致SVD：仅保留非零部分
  - 截断SVD：保留前k个奇异值，进行低秩近似
    - 对$Σ$对角线的奇异值，求累计值，按照阈值，取前k个，对U、V进行相应截断

### 10. SVD与推荐系统的关系
- 核心思想：“用户-物品”矩阵的潜在特征提取
  - 基于`“用户-物品评分矩阵”`R(m, n)
  - 目标：通过SVD对R进行低秩近似，提取用户和物品的潜在特征，从而预测物品的评分
- 具体应用
  - 1）矩阵分解
    - 将评分矩阵R分解为：$R ≈ UΣV^T$
      - U：(m, k)：用户潜在特征矩阵（每行代表一个用户的k维特征）
      - Σ：(k, k)：对角矩阵，对角线上的元素是奇异值，表示特征重要性
      - V：(n, k)：物品潜在特征矩阵（每行代表一个物品的k维特征）
    - 实际中，常简化为：
      - $R ≈ UV^T$ (Σ合并到U或V中)
  - 2）预测评分
    - $\hat r_{ui} = u_u \cdot v_i^T$
      - $u_u$：用户u的潜在特征向量
      - $v_i$：物品i的潜在特征向量

### 11. “用户-物品”评分矩阵
- 结构：二维矩阵
  - 行：用户，每个用户对应唯一行索引
  - 列：物品，其中的每个列代表了用户对每个物品的评分，每个物品对应唯一列索引
- 通常是一个高维且稀疏的矩阵
- 构建评分矩阵的步骤
  - 第1步，数据收集
    - 显示反馈数据：用户直接给出的评分
    - 隐式反馈数据：用户行为数据
      - 如：点击，浏览时长，购买记录
      - 需要转换为评分
  - 第2步，数据清洗
    - 去重：去除重复的用户-物品记录
    - 异常值处理：超出合理范围的评分
    - 缺失值处理：标记为0或NaN
  - 第3步，将用户id和物品id，转换为从0开始的连续数值索引
    - 使用LabelEncoder
      - from sklearn.preprocessing import LabelEncoder
  - 第4步，矩阵填充
    - 创建 (m, n) 空矩阵
      - m：用户数量
      - n：物品数量
    - 填充评分
      - import pandas as pd
      - data = pd.read_csv("data.csv")
      - user_item_matrix = data.pivot(index="user_id", columns="item_id", values="rating").fillna(0)
    - 转换为稀疏矩阵，以节省内存
      - from scipy.sparse import csr_matrix
      - csr_matrix(user_item_matrix.values)
    - 或者，直接用这个方案
        rows = data[index].values
        cols = data[column].values
        scores = data[value].values

        n_users = data[index].max() + 1
        n_items = data[column].max() + 1
        csr_matrix((scores, (rows, cols)), shape=(n_users, n_items))

### 12. 基于SVD矩阵分解的推荐
- 构建矩阵
  - 列：每个用户的播放记录
  - 行：每一首歌
- 对矩阵进行SVD分解
- 步骤：
  - 第1步，计算分值：歌曲被当前用户播放的次数 / 用户的所有歌曲的播放次数
  - 第2步，数据清理
    - 将用户id转换为数值
    - 将歌曲id转换为数值
  - 第3步，创建coo_matrix矩阵（稀疏矩阵）
    - 常见的稀疏矩阵储存形式
      - 坐标格式
      - 压缩行格式
      - 压缩列格式
  - 第4步，将矩阵进行SVD分解（截断SVD）
  - 第5步，计算推荐